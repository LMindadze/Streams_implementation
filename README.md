# Tolerant Streams
In this task we want to take a closer look at streams and exceptions. The aim is to implement a stream that can cope better with exceptions and also offers various operations so that it can be used, for example, for reading files.
Many classes / interfaces that are created here are internals of the stream implementation and should therefore be hidden, the same applies to methods and the like, even most of the tasks required. This will not be fully tested, but at least keep a large part of the implementation at package private level. Exceptions to this are the methods of the stream interface, the exception classes and the functional interfaces that Stream uses. They are needed by our users of the streams and must therefore be public. You can hide the rest as deeply as you like, but the methods / classes mentioned in the exercise should at least be package private.
The most important criterion for the tests is a functioning stream implementation.
Our stream should allow the passing through of null values, so do not throw null exceptions in the following classes for the stream implementation, unless it is explicitly required (also no unintentional NullPointerExceptions).
## API and Accessories
We need for our own streams …
* A class StreamElement <T>, which contains an element of our stream, as well as additional information about occurred exceptions. An element of the generic type and a list of exceptions that have occurred are required as attributes. It is in exactly one of two possible valid states: either "regular": there is an element (which can generally also be null) and an empty exception list, or "incorrect": there are exceptions in the list and the element attribute is null. So there must never be a non-zero element together with exceptions, and neither can uninitialized list of exceptions (null).
  StreamElement <T> should be immutable (see below).
  There are also the following object methods:
    * T getElement () returns the element.
    * List <Exception> getExceptions () returns a java.util.List containing the exceptions.
    * boolean hasExceptions () indicates whether there are any exceptions for this StreamElement.
    * <R> StreamElement <R> withExceptionAdded (Exception) converts a regular to faulty StreamElement by returning a new faulty one with this exception, or a new faulty one is returned with the exception in the list. The method allows the generic type of the new StreamElement to be changed on purpose, as that is quite useful.
    * Even without adding an exception, changing the generic type is very practical, so we write another method <R> StreamElement <R> tryAdapt (). The method must fail on a regular StreamElement (useful exceptions see below).
    * A static method of creating StreamElement would be useful. To do this, implement <T> StreamElement <T> of (T t), which returns a regular StreamElement with t as content.
  It is optional for this class to write two subclasses with the specified behavior (regular and faulty) for both forms of StreamElement. If you choose to do this, keep the visibility of these subclasses at private / package private; the same applies to the constructor.
  Also overwrite hashCode (), equals (Object) so that only the element of the StreamElement plays a role. It is also sensible to overwrite toString.
* An interface StreamIterator <T>, which defines the following (abstract) methods
  * boolean hasNext () returns whether the StreamIterator has unused elements.
  * StreamElement <T> next () returns the next StreamElement, or throws a suitable NoSuchElementException if there is no more element in the stream.
  * OptionalLong getSize () returns the exact number of elements as OptionalLong, if available; otherwise an empty OptionalLong.
    In addition, there should be the following static methods that generate a suitable StreamIterator: * <T> StreamIterator<T> of(Collection<T>) * <T> StreamIterator<T> of(Iterable<T>) * <T> StreamIterator<T> of(T[]) * <T> StreamIterator<T> of(java.util.stream.Stream<T>)
    Since all 4 types can be converted into an iterator, you are welcome to take advantage of this during the implementation and forward the method calls (if possible). You just have to wrap the elements in new StreamElement. Since the size of the array and the collection is known, you should make it accessible via getSize (). The size of the other two is unknown. How you create the StreamIterators is up to you, one possibility is to create anonymous StreamIterator subclasses for them, as with Iterator (see corresponding exercises).
* The immutable class StreamCharacteristics, with which we can pass useful information about the stream through the various stream operations and make a few optimizations.
  For this we need the following methods (and matching attributes):
    * OptionalLong getStreamSize () - the size of the stream, if known (analogous to StreamIterator)
    * boolean isDistinct () - whether the stream contains no duplicates (analogous to java.util.streamStream.distinct () or the property of a Set).
    * boolean isChecked () - whether our stream possibly contains checked exceptions.
  The normal case is that no size is known, there can be duplicates and the stream does not contain any checked exceptions. You can create a static StreamCharacteristics variable for this if you want. Likewise, methods like with ... (...) could be quite useful (sometimes called "Wither") that just return a new StreamCharacteristics object with the other property (we will often need to transform StreamCharacteristics).
  It could look like this: StreamCharacteristics.regular (). WithStreamSize (10) .withDistinct (true). As long as StreamCharacteristics remains unchangeable, you are free to do so.
  Create another static method StreamCharacteristics regular (), which delivers the / a normal case StreamCharacteristics object.
* The functional interface ThrowingFunction <T, R> and ThrowingPredicate <T>, both of which adopt the only abstract method of the respective functional interface from Java (java.util.function.Function and java.util.function. Predicate), but allow to throw any exceptions in the method. Mark both with the annotation for functional interfaces @ FunctionalInterface.
  (Optional thought: Expanding function and predicate is not possible here, why not?)
* The interface Stream <T> can already be found in the repository in order to avoid unnecessarily complicated description of the methods and to be able to test them better. You will also find information there for each method on how to behave.
  Observing this documentation and the description of the behavior is part of the implementation task!
  A few more notes:
    * "Faulty", "error-free" and "regular" (the last two are synonymous) refer to the state of the StreamElements to which the element belongs.
    * The generics with wildcards (the ?), in this case, can be treated like T,R or List <Exception>. The only advantage is a higher reusability, so that for example (Object o) -> o.toString () or Object :: toString instead of (Integer i) -> i.toString () map () of a stream can be used by integers.
    * Terminal stream operation is the same as with standard Java streams, at this point it is evaluated and is then used up / no longer reusable.
  A more detailed description of what to do is below, don't worry.
* The RuntimeException subclasses CheckedStreamException and ErrorsAtTerminalOperationException, which in the specified places (with good error messages).
## Stream Internals
Now to the actual implementation, what is needed here:
* An interface StreamOperation <T> that defines the following methods:
  void start(StreamCharacteristics upstreamCharacteristics)
  This method is called before processing the stream starts. It receives the resulting characteristics of the stream before the stream operation. Objects can be initialized in it, if the operation is state-affected, and the stream characteristics can also be adjusted there, with which all subsequent operations work. The idea is that this method will be called recursively for all operations on the stream, starting with the first through the last, the terminal stream operation. The passed StreamCharacteristics can / are used for optimization.
    * void acceptElement(StreamElement<T>)
  The method takes a StreamElement, does something with it, and - in most cases - passes it on. More details on the implementation of the stream methods.
    * void finish()
  Analogous to start marks the end of the stream (more precisely: the previous stream). The method should be called if no more new elements are transferred via acceptElement. However, there is still a lot that can be done here, including passing elements on to the following stream. This method is also called recursively stream downwards.
    * boolean needsMoreElements()
  This method is used in a similar way to hasNext for the iterator, but in the opposite direction. It is called by the StreamOperation before further elements are required via acceptElement. It is therefore a crucial component in ensuring that our streams are "lazy", i.e. only process elements that are actually needed (e.g. findFirst). This method will also be used recursively most of the time.
  StreamOperation abstracts a single operation in the stream pipeline, e.g. filter, map, distinct, …
* An interface TerminalStreamOperation <T, R>, which extends both StreamOperation <T> and Supplier <R>. You don't necessarily need new methods, but maybe there are sensible default implementations here? Especially with start there would be a property listed in the JavaDocs of theStream methods, which is shared by all terminal stream operations. With a little caution, this could be shifted to TerminalStreamOperation.
* A small functional interface StreamOperable <T> that defines a method StreamOperation <T> getStreamOperation (). It is only intended to make it easier to handle terminal stream operations. Give it a suitable annotation.
* The (abstract) class AbstractStreamPart <IN, OUT>.
  This is now at the heart of the stream implementation, and this is where you have the most freedom of design.
  Let's implement Stream <OUT> and StreamOperable <IN>, and then pause for a moment and consider what we want to achieve with them and what that means now. AbstractStreamPart is a piece of our stream, which - at least in this stream section - can process objects of type IN. It can at least do this via the StreamOperation <IN> that getStreamOperation () returns from StreamOperable <IN>. OUT, on the other hand, is the type of stream that comes out of the stream section and thus also the type of the stream section itself. For many stream operations, Stream <OUT> is the return type, but the stream it returns initially has nothing to do with the stream section in which the method is located or where it is currently being executed. A good example is map, there the return type is Stream <R>. Therefore, OUT should not be confused with the type resulting from stream methods such as filter; it is the output of the current section and the input of the stream section newly created by a stream method such as filter. The only reason that Stream <OUT> is the return of the filter method is thatfilter does not change the stream type.
  But let's start step by step.
  AbstractStreamPart is part of our entire stream pipeline, and thus part of chained stream operations. Therefore, a structure similar to a doubly linked list works well. At least the subsequent stream operation must be known so that our StreamOperation <IN> can also forward the elements down the stream. To do this, create an attribute StreamOperable <OUT> next, which should point to the next element in the pipeline. At first there isn't any, it's zero. Therefore provide a method setNext (StreamOperable <OUT>), which sets next to the transferred element, if next was not yet set. If next has already been set, a suitable IllegalStateException should be thrown.
  As far as the stream methods are concerned, you can first implement them with return null; and satisfy the compiler. We'll come back here later.
  In addition, create an abstract method SourcePart <?> GetSource (), with which the source stream section can be (recursively) obtained. Since such a class does not yet exist, we need to create it:
* Create the concrete class SourcePart <T> that inherits from AbstractStreamPart <T, T>. It is the source of all streams and therefore sits at the very beginning of our streams. It gets a StreamIterator <T> and StreamCharacteristics in the constructor. You are welcome to add other suitable constructors. Neither need be externally accessible, but we still need it internally; create attributes for both.
  Then implement getSource () sensibly and getStreamOperation () as well, depending on the type of your implementation of the next task, different things are possible.
  Lastly, create a void processStream() method that will actually process the stream. To do this, pass the elements from the StreamIterator to the first real stream operation (you can get them here). Also think of start and finish, and pass only as many elements as possible and as intended by the stream operation (there is a method for this).
* Now create the abstract class IntermediatePart <IN, OUT>, which also inherits from AbstractStreamPart <IN, OUT>. Very little changes here either. Since this is a middle link in the linked list of stream operations, we only want to add an attribute to the previous AbstractStreamPart <?, IN>. Create a suitable constructor for this purpose, and set the next of the predecessor accordingly. Implement getSource () appropriately.
* If you want, you can create additional classes to help with the tasks at hand. A suggestion would be an abstract class ChainedStreamOperation <T, R>, which implements StreamOperation <T> and has StreamOperation <R> downstream as an attribute to which it forwards method calls by default (start, finish, needsMoreElements) . In the constructor there could be a StreamOperation <R> or StreamOperable <R>. A getter downstream () is also useful. Here you can choose what you want to implement or outsource parts of it to new, abstract methods. If you work cleverly here, you will have an easier and much shorter time implementing the various stream operations.
## The Last Step
Now implement the previously omitted methods of the stream interface.
Pay close attention to the comments / JavaDocs of the individual stream methods. You determine the behavior, even in edge cases.
For non-terminal stream methods (filter, map, ..) you can create anonymous IntermediateParts, pass their predecessors -this - and return them.
For this - depending on the implementation - only getStreamOperation has to be implemented. There you can e.g. generate an anonymous StreamOperation <OUT> again. (Here a standard implementation like ChainedStreamOperation is worthwhile.) Note that this anonymous, newly created stream operation will be the successor of the current one, so its IN is always the OUT of the current AbstractStreamPart.
For terminal stream methods we first want to create an auxiliary method in AbstractStreamPart:
<R> R evaluate (TerminalStreamOperation <OUT, R>), which receives a TerminalStreamOperation, executes the stream and returns the result. Here you can use setNext, then let getSource () execute the stream and finally get the result from TerminalStreamOperation.
You can now comfortably carry out and evaluate the terminal stream operations; You can do this, for example, via Realize anonymous classes with the desired behavior. Pay particular attention to the appropriate implementation needsMoreElements (), and use start (StreamCharacteristics). For example, count () should check the StreamCharacteristics and behave according to the documentation.
If you want to get an idea of the overall process, you can look at this example process. This does not include all operations, but it does show how the communication between the main parts of the stream is carried out. The case shown corresponds roughly to Stream.of(1, 2, 3).filter(i -> i > 1).map(i -> i * i).distinct().filter(i -> i % 2 == 0).findFirst() and would return an Optional.of(4).

Tips for implementing the behavior:
* It is best to reduce your try-catch only to the execution of the critical part (e.g. Predicate.test, Function.apply). The forwarding of an element to downstream () should not be included in order not to swallow errors in the end operation.
* Since you are working with StreamElements, it is very often necessary to differentiate between the state. With map you can take advantage of e.g. tryAdapt(). For everything else you can repackage elements in StreamElements.
* Be sure to adjust the StreamCharacteristics and think carefully about what should be changed.
  Examples:
  For example, the size after filter and the like is definitely unknown, but whether the stream is duplicate-free does not change. With map the other way round, the size remains what it was, but freedom from duplicates can no longer be guaranteed.
* You can also outsource the anonymous classes to independent classes and give them suitable names, e.g. CountingTerminalOp or MappingOp. Use what you like better.
* For distinct it is necessary to first collect all elements and then forward them when all are known. Here it makes sense to move the forwarding to downstream () to finish. However, the whole thing can be skipped if the stream is already distinct.
* Only catch Exceptions, please do not catch Error or Throwable, as these are too serious errors to be caught - especially in a stream.
* The most important reference work on method behavior is the documentation of the Stream API. If you are uncertain, stick to it when in doubt.
  Finally implement the static methods in Stream by returning suitable SourceParts. (You already have useful methods for this in StreamIterator; also pay attention to the special position of Set)
  Now you can enjoy your own streams without limits and use them, for example, for file access or the like, especially when checked exceptions interfere in streams. If you wish, you can (at your own risk) extend the functionality of your streams (sorted (), forEach (), …).
